# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations
import types
import typing
from typing import Any, Callable, Mapping, Optional, Sequence, Iterable, TypeAlias, Iterator

from arolla import arolla

NotImplementedType = types.NotImplementedType
_JaggedShape = arolla.AnyQValue

class SlicingHelper:
    def __getitem__(self, s: Any) -> DataSlice: ...

class ListSlicingHelper:
    def __getitem__(self, s: Any) -> DataSlice: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[DataSlice]: ...


class DataSlice(arolla.QValue):
    _HAS_DYNAMIC_ATTRIBUTES = True

    @classmethod
    def from_vals(cls, x: Any, /, schema: DataSlice | None = None) -> DataSlice: ...
    @classmethod
    def _from_py_impl(
        cls,
        py_obj: Any,
        dict_as_obj: bool,
        itemid: DataSlice | None,
        schema: DataSlice | None,
        from_dim: int,
    ) -> DataSlice: ...
    @classmethod
    def _unspecified(cls) -> DataSlice: ...

    def get_bag(self) -> DataBag: ...
    def has_bag(self) -> DataSlice: ...
    def with_bag(self, bag: DataBag | None, /) -> DataSlice: ...
    def no_bag(self) -> DataSlice: ...
    def fork_bag(self) -> DataSlice: ...
    def freeze_bag(self) -> DataSlice: ...
    def with_merged_bag(self) -> DataSlice: ...
    def enriched(self, *bag: DataBag) -> DataSlice: ...
    def updated(self, *bag: DataBag) -> DataSlice: ...

    def get_schema(self) -> DataSlice: ...
    def get_shape(self) -> _JaggedShape: ...
    def get_ndim(self) -> DataSlice: ...
    def get_dtype(self) -> DataSlice: ...
    def get_item_schema(self) -> DataSlice: ...
    def get_key_schema(self) -> DataSlice: ...
    def get_value_schema(self) -> DataSlice: ...
    def get_obj_schema(self) -> DataSlice: ...
    def is_list_schema(self) -> bool: ...
    def is_dict_schema(self) -> bool: ...
    def is_entity_schema(self) -> bool: ...
    def is_struct_schema(self) -> bool: ...
    def is_primitive_schema(self) -> bool: ...
    def is_primitive(self) -> bool: ...
    def is_list(self) -> bool: ...
    def is_dict(self) -> bool: ...
    def is_entity(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_mutable(self) -> bool: ...
    def internal_is_itemid_schema(self) -> bool: ...

    def with_schema(self, schema: DataSlice, /) -> DataSlice: ...
    def set_schema(self, schema: DataSlice, /) -> DataSlice: ...
    def with_schema_from_obj(self) -> DataSlice: ...
    def embed_schema(self) -> DataSlice: ...

    def get_attr(
        self, attr_name: str | DataSlice, /, default: Any = None
    ) -> DataSlice: ...
    def has_attr(self, attr_name: str | DataSlice) -> DataSlice: ...
    def maybe(self, attr_name: str | DataSlice) -> DataSlice: ...
    def set_attr(
        self, attr_name: str | DataSlice, value: Any, /, overwrite_schema: bool = False
    ) -> None: ...
    def set_attrs(self, *, overwrite_schema: bool | DataSlice = False, **attrs: Any) -> None: ...
    def with_attr(
        self,
        attr_name: str | DataSlice,
        value: Any,
        overwrite_schema: bool | DataSlice = False,
    ) -> DataSlice: ...
    def with_attrs(
        self, *, overwrite_schema: bool | DataSlice = False, **attrs: Any
    ) -> DataSlice: ...
    def strict_with_attrs(self, **attrs: Any) -> DataSlice: ...
    def get_attr_names(self, *, intersection: bool) -> list[str]: ...

    def new(self, **attrs: Any) -> DataSlice: ...
    def clone(
        self, *, itemid: DataSlice | None = None, schema: DataSlice = None, **overrides: Any
    ) -> DataSlice: ...
    def shallow_clone(
        self, *, itemid: DataSlice | None = None, schema: DataSlice = None, **overrides: Any
    ) -> DataSlice: ...
    def deep_clone(self, schema: DataSlice = None, **overrides: Any) -> DataSlice: ...
    def deep_uuid(
        self, schema: DataSlice = None, *, seed: str | DataSlice = ''
    ) -> DataSlice: ...
    def ref(self) -> DataSlice: ...
    def stub(self, attrs: DataSlice = []) -> DataSlice: ...

    def reshape(self, shape: _JaggedShape) -> DataSlice: ...
    def reshape_as(self, shape_from: DataSlice) -> DataSlice: ...
    def flatten(
        self, from_dim: int | DataSlice = 0, to_dim: int | DataSlice | None = None
    ) -> DataSlice: ...
    def flatten_end(self, n_times: int | DataSlice = 1) -> DataSlice: ...
    def repeat(self, sizes: Any) -> DataSlice: ...
    def take(self, indices: Any) -> DataSlice: ...
    def implode(
        self, ndim: int | DataSlice = 1, itemid: DataSlice | None = None
    ) -> DataSlice: ...
    def explode(self, ndim: int | DataSlice = 1) -> DataSlice: ...
    def expand_to(self, target: Any, ndim: int | DataSlice | None = None) -> DataSlice: ...

    def select(
        self, fltr: Any, expand_filter: bool | DataSlice = True
    ) -> DataSlice: ...
    def select_present(self) -> DataSlice: ...
    def select_items(self, fltr: Any) -> DataSlice: ...
    def select_keys(self, fltr: Any) -> DataSlice: ...
    def select_values(self, fltr: Any) -> DataSlice: ...

    def append(self, value: Any, /) -> None: ...
    def pop(self, index: Any = -1) -> DataSlice: ...
    def clear(self) -> None: ...
    def list_size(self) -> DataSlice: ...
    def dict_size(self) -> DataSlice: ...
    def get_keys(self) -> DataSlice: ...
    def get_values(self, key_ds: Any = None) -> DataSlice: ...
    def with_dict_update(self, keys: Any, values: Any = None) -> DataSlice: ...
    def with_list_append_update(self, append: Any) -> DataSlice: ...

    def follow(self) -> DataSlice: ...
    def extract(self, schema: DataSlice = None) -> DataSlice: ...
    def extract_bag(self, schema: DataSlice = None) -> DataBag: ...
    def get_itemid(self) -> DataSlice: ...
    def get_present_count(self) -> DataSlice: ...
    def get_size(self) -> DataSlice: ...
    def get_sizes(self) -> DataSlice: ...
    def with_name(self, name: Any) -> DataSlice: ...

    def to_py(
        self, max_depth: int = 2, obj_as_dict: bool = False, include_missing_attrs: bool = True
    ) -> Any: ...
    def to_pytree(
        self, max_depth: int = 2, include_missing_attrs: bool = True
    ) -> Any: ...
    def _to_py_impl(
        self, max_depth: int = 2, obj_as_dict: bool = False, include_missing_attrs: bool = True
    ) -> Any: ...
    def _to_proto(self, message_class: Any) -> Any: ...
    def internal_as_py(self) -> Any: ...
    def internal_as_arolla_value(self) -> arolla.AnyQValue: ...
    def internal_as_dense_array(self) -> arolla.AnyQValue: ...

    def display(self, options: Any | None = None) -> None: ...
    def __dir__(self) -> list[str]: ...
    def _debug_repr(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...

    def __neg__(self) -> DataSlice: ...
    def __pos__(self) -> DataSlice: ...
    def __invert__(self) -> DataSlice: ...
    def __add__(self, other: Any) -> DataSlice: ...
    def __radd__(self, other: Any) -> DataSlice: ...
    def __sub__(self, other: Any) -> DataSlice: ...
    def __rsub__(self, other: Any) -> DataSlice: ...
    def __mul__(self, other: Any) -> DataSlice: ...
    def __rmul__(self, other: Any) -> DataSlice: ...
    def __truediv__(self, other: Any) -> DataSlice: ...
    def __rtruediv__(self, other: Any) -> DataSlice: ...
    def __floordiv__(self, other: Any) -> DataSlice: ...
    def __rfloordiv__(self, other: Any) -> DataSlice: ...
    def __mod__(self, other: Any) -> DataSlice: ...
    def __rmod__(self, other: Any) -> DataSlice: ...
    def __pow__(self, other: Any) -> DataSlice: ...
    def __rpow__(self, other: Any) -> DataSlice: ...
    def __and__(self, other: Any) -> DataSlice: ...
    def __rand__(self, other: Any) -> DataSlice: ...
    def __or__(self, other: Any) -> DataSlice: ...
    def __ror__(self, other: Any) -> DataSlice: ...
    def __xor__(self, other: Any) -> DataSlice: ...
    def __rxor__(self, other: Any) -> DataSlice: ...
    def __eq__(self, other: Any) -> DataSlice: ...
    def __ne__(self, other: Any) -> DataSlice: ...
    def __gt__(self, other: Any) -> DataSlice: ...
    def __ge__(self, other: Any) -> DataSlice: ...
    def __lt__(self, other: Any) -> DataSlice: ...
    def __le__(self, other: Any) -> DataSlice: ...

    def __lshift__(self, other: Any) -> DataSlice: ...
    def __rshift__(self, other: Any) -> DataSlice: ...
    def __rlshift__(self, other: Any) -> DataSlice: ...

    def __getitem__(self, key: str | bytes | slice | DataSlice | int) -> DataSlice: ...
    def __setitem__(self, key: str | bytes | slice | DataSlice | int, value: Any) -> None: ...
    def __delitem__(self, key: str | bytes | slice | DataSlice | int) -> None: ...

    @property
    def S(self) -> SlicingHelper: ...
    @property
    def L(self) -> ListSlicingHelper: ...


class DataBag(arolla.QValue):
    def is_mutable(self) -> bool: ...
    @staticmethod
    def empty() -> DataBag: ...
    @staticmethod
    def empty_mutable() -> DataBag: ...

    def new(self, arg: Any = None, /, *, schema: str | DataSlice | None = None, overwrite_schema: bool = False, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    @classmethod
    def _new_no_bag(cls, arg: Any = None, /, *, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    def new_shaped(self, shape: _JaggedShape, *, schema: str | DataSlice | None = None, overwrite_schema: bool = False, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    def new_like(self, shape_and_mask_from: DataSlice, *, schema: str | DataSlice | None = None, overwrite_schema: bool = False, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...

    def obj(self, arg: Any = None, /, *, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    @classmethod
    def _obj_no_bag(cls, arg: Any = None, /, *, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    def obj_shaped(self, shape: _JaggedShape, *, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...
    def obj_like(self, shape_and_mask_from: DataSlice, *, itemid: DataSlice | None = None, **attrs: Any) -> DataSlice: ...

    def uu(self, seed: str = '', *, schema: DataSlice = None, overwrite_schema: bool = False, **kwargs: Any) -> DataSlice: ...
    def uuobj(self, seed: str = '', **kwargs: Any) -> DataSlice: ...
    def uu_schema(self, seed: str = '', **attrs: Any) -> DataSlice: ...

    def new_schema(self, **attrs: Any) -> DataSlice: ...
    def named_schema(self, name: str | DataSlice, /, **attrs: Any) -> DataSlice: ...
    def dict_schema(self, key_schema: DataSlice, value_schema: DataSlice) -> DataSlice: ...
    def list_schema(self, item_schema: DataSlice) -> DataSlice: ...

    def dict(self, items_or_keys: dict[Any, Any] | Any | None = None, values: Any | None = None, *, key_schema: DataSlice | None = None, value_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def dict_shaped(self, shape: _JaggedShape, /, items_or_keys: dict[Any, Any] | Any | None = None, values: Any | None = None, *, key_schema: DataSlice | None = None, value_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def _dict_shaped(self, shape: _JaggedShape, items_or_keys: dict[Any, Any] | Any | None = None, values: Any | None = None, key_schema: DataSlice | None = None, value_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None, /) -> DataSlice: ...
    def dict_like(self, shape_and_mask_from: DataSlice, /, items_or_keys: dict[Any, Any] | Any | None = None, values: Any | None = None, *, key_schema: DataSlice | None = None, value_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def _dict_like(self, shape_and_mask_from: DataSlice, items_or_keys: dict[Any, Any] | Any | None = None, values: Any | None = None, key_schema: DataSlice | None = None, value_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None, /) -> DataSlice: ...

    def list(self, /, items: Any | None = None, *, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def _list(self, items: Any | None = None, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None, /) -> DataSlice: ...
    def list_shaped(self, shape: _JaggedShape, /, items: Any | None = None, *, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def _list_shaped(self, shape: _JaggedShape, items: Any | None = None, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None, /) -> DataSlice: ...
    def list_like(self, shape_and_mask_from: DataSlice, /, items: Any | None = None, *, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None) -> DataSlice: ...
    def _list_like(self, shape_and_mask_from: DataSlice, items: Any | None = None, item_schema: DataSlice | None = None, schema: DataSlice | None = None, itemid: DataSlice | None = None, /) -> DataSlice: ...
    def implode(self, x: DataSlice, /, ndim: int | DataSlice = 1, itemid: DataSlice | None = None) -> DataSlice: ...
    def _implode(self, x: DataSlice, /, ndim: int | DataSlice = 1, itemid: DataSlice | None = None) -> DataSlice: ...
    def concat_lists(self, *lists: DataSlice) -> DataSlice: ...
    def _concat_lists(self, *lists: DataSlice) -> DataSlice: ...

    def merge_inplace(self, other_bags: DataBag | Iterable[DataBag], /, *, overwrite: bool = True, allow_data_conflicts: bool = True, allow_schema_conflicts: bool = False) -> DataBag: ...
    def _merge_inplace(self, overwrite: bool = True, allow_data_conflicts: bool = True, allow_schema_conflicts: bool = False, *bags: DataBag | Iterable[DataBag]) -> DataBag: ...
    def adopt(self, slices: DataSlice, /) -> DataSlice: ...
    def adopt_stub(self, slices: DataSlice, /) -> DataSlice: ...
    def merge_fallbacks(self) -> DataBag: ...
    def fork(self, mutable: bool = True) -> DataBag: ...
    def freeze(self) -> DataBag: ...
    def with_name(self, name: str | Any) -> DataBag: ...
    def __getitem__(self, slices: DataSlice) -> DataSlice: ...
    def __lshift__(self, *dbs: DataBag) -> DataBag: ...
    def __rshift__(self, *dbs: DataBag) -> DataBag: ...

    def contents_repr(self, *, triple_limit: int = 1000) -> str: ...
    def _contents_repr(self, *, triple_limit: int = 1000) -> str: ...
    def data_triples_repr(self, *, triple_limit: int = 1000) -> str: ...
    def _data_triples_repr(self, *, triple_limit: int = 1000) -> str: ...
    def schema_triples_repr(self, *, triple_limit: int = 1000) -> str: ...
    def _schema_triples_repr(self, *, triple_limit: int = 1000) -> str: ...
    def get_approx_size(self) -> int: ...
    def _from_proto(self, message_list: list[Any], extensions_list: list[str] | None, itemid: DataSlice | None, schema: DataSlice | None, /) -> DataSlice: ...
    def _schema_from_proto(self, message_class: Any, extensions: list[str] | None, /) -> DataSlice: ...
